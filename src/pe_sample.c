/*
 * perf events self profiling example.
 *
 * This version uses the kernel to read the counter data. This is much
 * simpler but has a higher cost than doing it in userspace. The added
 * cost should only matter if you are profiling very small sections of
 * code.
 *
 * Requires perf_event.h from a recent kernel tree, or download from 
 * git via:
 *
 * wget -O perf_event.h "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob_plain;f=include/uapi/linux/perf_event.h;hb=HEAD"
 *
 * Build with:
 * gcc -O2 -o perf_events_example1 perf_events_example1.c
 *
 * Copyright 2012 Anton Blanchard, IBM Corporation <anton@au.ibm.com>
 */

#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <sys/syscall.h>
#include <unistd.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <sys/ioctl.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/prctl.h>

#include <linux/perf_event.h>

/* Profile everything (kernel/hypervisor/idle/user) or just user? */
#undef USERSPACE_ONLY

#ifndef __NR_perf_event_open
#if defined(__PPC__)
#define __NR_perf_event_open	319
#elif defined(__i386__)
#define __NR_perf_event_open	336
#elif defined(__x86_64__)
#define __NR_perf_event_open	298
#else
#error __NR_perf_event_open must be defined
#endif
#endif

static int count_total[] = {0,0};
static int event_fd[2];
static void *event_buf = NULL;

static inline
int sys_perf_event_open(struct perf_event_attr *attr, pid_t pid,
				      int cpu, int group_fd,
				      unsigned long flags)
{
	attr->size = sizeof(*attr);
	return syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);
}


static int
start_counters(int fd)
{
	return ioctl(fd, PERF_EVENT_IOC_REFRESH, 1);
}

static int
stop_counters(int fd)
{
	return ioctl(fd, PERF_EVENT_IOC_DISABLE);
}

static int
get_fd(int sig_fd)
{
	for(int i=0; i<2; i++) {
		if (event_fd[i] == sig_fd)
			return i;
	}
	return -1;
}

static 
void event_handler(int signum, siginfo_t *info, void *uc)
{
	int ret;

	if (info->si_code < 0) {
		fprintf(stderr, "Required signal not generated\n");
		return;
	}

	if (info->si_code != POLL_HUP) {
		fprintf(stderr, "POLL_HUP signal not generated by SIGIO, %d\n", info->si_code);
		return;
	}

	int fd = info->si_fd;
	int index = get_fd(fd);
	if (index < 0) {
		fprintf(stderr, "unknown fd: %d\n", fd);
	}

	count_total[index]++;

	ret=start_counters(fd);

	(void) ret;
}


static
int setup_counters(uint64_t type, uint64_t config)
{
	static int index = 0;
	struct perf_event_attr attr;

	memset(&attr, 0, sizeof(attr));
#ifdef USERSPACE_ONLY
	attr.exclude_kernel = 1;
	attr.exclude_hv = 1;
	attr.exclude_idle = 1;
#endif

	attr.disabled 	 = 1;
	attr.type 	 	 = type;
	attr.config 	 = config;
	attr.sample_freq = 4000;
	attr.freq 		 = 1;
	attr.wakeup_events = 1;
	attr.size		   = sizeof(struct perf_event_attr);
	attr.sample_type   = PERF_SAMPLE_CALLCHAIN;

	event_fd[index] = sys_perf_event_open(&attr, 0, -1, -1, 0);
	if (event_fd[index] < 0) {
		perror("sys_perf_event_open");
	}
	int fd = event_fd[index];
	index++;
	return fd;
}


static void
read_counters(int index)
{
	size_t res;
	unsigned long long counter_result;

	res = read(event_fd[index], &counter_result, sizeof(unsigned long long));
	assert(res == sizeof(unsigned long long));

	printf("counter:\t\t%lld\nNum counter: %d\n\n", counter_result, count_total[index]);
}

static void
setup_handler()
{
	struct sigaction act;

	memset(&act, 0, sizeof(act));
	act.sa_sigaction = event_handler;
	act.sa_flags     = SA_SIGINFO;
	sigaction(SIGIO, &act, 0);
}

static void*
setup_buffer(int fd)
{
	static const int buffer_pages = 1;
	size_t pagesize = sysconf(_SC_PAGESIZE);

	void *buf = mmap(NULL, (buffer_pages + 1) * pagesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
	if (buf == MAP_FAILED) {
		fprintf(stderr, "Can't mmap buffer\n");
		return NULL;
	}

	size_t pgmsk = (buffer_pages * pagesize) - 1;
	return buf;
}

int instructions_million(void) {

#if defined(__i386__) || (defined __x86_64__)
	asm(	"	xor	%%ecx,%%ecx\n"
		"	mov	$499999,%%ecx\n"
		"test_loop:\n"
		"	dec	%%ecx\n"
		"	jnz	test_loop\n"
		: /* no output registers */
		: /* no inputs */
		: "cc", "%ecx" /* clobbered */
	);
	return 0;
#elif defined(__PPC__)
	asm(	"	nop			# to give us an even million\n"
		"	lis	15,499997@ha	# load high 16-bits of counter\n"
		"	addi	15,15,499997@l	# load low 16-bits of counter\n"
		"55:\n"
		"	addic.  15,15,-1              # decrement counter\n"
		"	bne     0,55b                  # loop until zero\n"
		: /* no output registers */
		: /* no inputs */
		: "cc", "15" /* clobbered */
	);
	return 0;
#elif defined(__ia64__)

	asm(	"	mov	loc6=166666	// below is 6 instr.\n"
		"	;;			// because of that we count 4 too few\n"
		"55:\n"
		"	add	loc6=-1,loc6	// decrement count\n"
		"	;;\n"
		"	cmp.ne	p2,p3=0,loc6\n"
		"(p2)	br.cond.dptk	55b	// if not zero, loop\n"
		: /* no output registers */
		: /* no inputs */
		: "p2", "loc6" /* clobbered */
	);
	return 0;
#elif defined(__sparc__)
	asm(	"	sethi	%%hi(333333), %%l0\n"
		"	or	%%l0,%%lo(333333),%%l0\n"
		"test_loop:\n"
		"	deccc	%%l0		! decrement count\n"
		"	bnz	test_loop	! repeat until zero\n"
		"	nop			! branch delay slot\n"
		: /* no output registers */
		: /* no inputs */
		: "cc", "l0" /* clobbered */
	);
	return 0;
#elif defined(__arm__)
	asm(	"	ldr	r2,count	@ set count\n"
		"	b       test_loop\n"
		"count:	.word 333332\n"
		"test_loop:\n"
		"	add	r2,r2,#-1\n"
		"	cmp	r2,#0\n"
		"	bne	test_loop	@ repeat till zero\n"
		: /* no output registers */
		: /* no inputs */
		: "cc", "r2" /* clobbered */
	);
	return 0;
#elif defined(__aarch64__)
	asm(	"	ldr	x2,=333332	// set count\n"
		"test_loop:\n"
		"	add	x2,x2,#-1\n"
		"	cmp	x2,#0\n"
		"	bne	test_loop	// repeat till zero\n"
		: /* no output registers */
		: /* no inputs */
		: "cc", "r2" /* clobbered */
	);
	return 0;
#endif

	return -1;

}

int
main(int argc, char *argv[])
{
	setup_handler();

	int fd = setup_counters(PERF_TYPE_HARDWARE, PERF_COUNT_HW_CPU_CYCLES);
	if (fd < 0) {
		exit(1);
	}
	printf("fd cycles: %d\n", fd);

	fd = setup_counters(PERF_TYPE_HARDWARE, PERF_COUNT_HW_INSTRUCTIONS);
	if (fd < 0) {
		exit(1);
	}
	printf("fd instructions: %d\n", fd);
	event_buf = setup_buffer(fd);
	if (event_buf == NULL) {
		exit(2);
	}

	start_counters(fd);

	/* Do something */
	instructions_million();

	stop_counters(fd);
	printf("Remainder of sleep: %d\n", rem);
	read_counters(0);
	read_counters(1);

	return 0;
}
